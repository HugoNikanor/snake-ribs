# What is RIBS?
A super small and easy to use collection of functions
to help with some things pygame don't help with.

Also note that not everything is documented, if it's not
documented you probably don't have to care about it.

# `key_down(key)`
Takes a key, that's either a keycode or a character,
and says if it's down or not.
<div class="arg-block">
<div class="arg-name">`key`</div> - Is a string with the character or a keycode (pg.K_****) of the button to check.<br>
</div>

## ex
!--
if key_down("a"):
    print("COWABUNGA")
--!
This code would print "COWABUNGA" to the console when the "a" button is held.

## ex
!--
if key_down(pg.K_LEFT):
    print("Move left")
--!
This code would print "Move left" to the console when the spacebar is held.

# `key_released(key)`
Takes a key, that's either a keycode or a character,
and says if it was released this frame.
<div class="arg-block">
<div class="arg-name">`key`</div>- Is a string with the character or a keycode (pg.K_****) of the button to check.<br>
</div>

## ex
!--
if key_released("a"):
    print("hold longer maybe?")
--!
this code would print "hold longer maybe?" to the console when the "a" button was released.

# `key_pressed(key)`
Takes a key, that's either a keycode or a character,
and says if it was pressed down this frame.
<div class="arg-block">
<div class="arg-name">`key`</div>- Is a string with the character or a keycode (pg.K_****) of the button to check.<br>
</div>

## ex
!--
if key_down(pg.K_SPACE):
    print("JUMP")
--!
This code would print "JUMP" to the console when the spacebar is pressed, and only that frame.

# `draw_transformed(img, position, scale=(1., 1.), degrees=0)`
Draws a sprite in a sprite centered around `position` scaled by `scale` and
rotated clockwise `degrees`. This function is just a convinience function to
make it simpler to draw sprites.
<div class="arg-block">
<div class="arg-name">`img`</div> - Is the image to be used as a sprite.<br>
<div class="arg-name">`position`</div> - Is the center position of the sprite.<br>
<div class="arg-name">`scale`</div> - If you want to apply a scale factor to the sprite.
         (You don't need to supply this argument.)<br>
<div class="arg-name">`degrees`</div> - If you want to rotate the sprite. (You don't need to supply this argument.)<br>
</div>

## ex
!--
assets["teapot"] = pg.image.load("teapot.png")
draw_transformed(assets["teapot"], (100, 100))
--!
This code would draw the "teapot.png" image (given that you have one) 100
pixels to the right of the left edge, and 100 pixels bellow the top edge of the
window.

## ex
!--
assets["teapot"] = pg.image.load("teapot.png")
draw_transformed(assets["teapot"], (100, 100), (1, 0.5), time)
--!
This code would draw the "teapot.png" image (given that you have one),
and given that `time` was the "time since the program started", this
would draw a sprite at (100, 100) shrunk to half long the y axis, rotating
around it's center.

# `overlap_data(a, b)`
Returns the exis that points from a to b, and the depth of the collision.
If the depth is negative it means they are far away from overlapping.

Note that this function is not super important, you probably want
to use `solve_rect_overlap(a, b)`

<div class="arg-block">
<div class="arg-name">`a`</div>- A `pg.Rect(minx, miny, width, height)`.<br>
<div class="arg-name">`b`</div> - A `pg.Rect(minx, miny, width, height)`. (Same as `a`)<br>
</div>

## ex
!--
rect_a = pg.Rect(200, 200, 100, 100)
rect_b = pg.Rect(250, 250, 50, 100)
normal, depth = overlap_data(rect_a, rect_b)
overlap = depth > 0
print(overlap)
--!
This code would print "True" since the rectangles overlap, and thus
the depth of their overlap is positive.

# `solve_rect_overlap(a, b, vel_a=(0, 0), vel_b=(0, 0), mass_a=1, mass_b=1, bounce=0)`
This function checks if `a` and `b` overlap, if they do the collision
is solved and two new rectangles moved out of eachother along the shortest
collision vector are returned along with their velocities.

<div class="arg-block">
<div class="arg-name">`a`     </div> - A `pg.Rect(minx, miny, width, height)`.<br>
<div class="arg-name">`b`     </div> - A `pg.Rect(minx, miny, width, height)`. (Same as `a`)<br>
<div class="arg-name">`vel_a` </div> - The velocity `a` has, given as a tuple.<br>
<div class="arg-name">`vel_b` </div> - The velocity `b` has, given as a tuple.<br>
<div class="arg-name">`mass_a`</div> - The mass of `a`, 0 mass means it's static and imovable.<br>
<div class="arg-name">`mass_b`</div> - The mass of `b`, 0 mass means it's static and imovable.<br>
<div class="arg-name">`bounce`</div> - How bouncy the collision should be. Values higher than 1 will introduce
           more energy to the system and might cause glitches. Values lower than 0
           does not make sense.<br>
</div>

## ex
!--
rect_a = pg.Rect(200, 200, 100, 100)
vel_a = (0, 1000)
rect_b = pg.Rect(250, 250, 50, 100)
vel_b = (0, 0)
rect_a, rect_b, vel_a, vel_b, hit = solve_rect_overlap(rect_a, rect_b, vel_a, vel_b, bounce=1.0)
--!
This code will create a collision between `rect_a` and `rect_b`. The collision will send
rect_b flying since all the energy from `rect _a` is transfered to `rect_b`.
